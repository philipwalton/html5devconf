<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>The Dark Side of CSS Polyfills &mdash; dotCSS (Dec. 2, 2016)</title>

  <script src="bower_components/webcomponentsjs/webcomponents-lite.js"></script>

  <link rel="import" href="bower_components/slide-deck/a-slide-deck.html">
  <link rel="import" href="bower_components/slide-deck/a-slide.html">
  <link rel="import" href="bower_components/slide-deck/code-block.html">

  <link rel="stylesheet" href="theme.css">
</head>
<body unresolved>

  <a-slide-deck width="1920" height="1080" padding="0">

    <a-slide>
      <hgroup>
        <h1>The Dark Side<br>of Polyfilling CSS</h1>
        <h2>Secrets polyfill authors won't tell you.</h2>
      </hgroup>
      <p class="small">
        <a href="https://philipwalton.com">Philip Walton</a> /
        <a href="https://philipwalton.com">philipwalton.com</a> /
        <a href="https://twitter.com/philwalton">@philwalton</a>
      </p>
    </a-slide>

    <a-slide>
        <img class="Screenshot" src="images/smashing-article.png" alt="CSS Houdini on Smashing Magazine" width="1200" height="800" />
      </figure>

    </a-slide>

    <a-slide>
      <blockquote>
        <p>Why is it so hard<br>to write a CSS Polyfill?</p>
      </blockquote>
    </a-slide>

    <a-slide>
      <p>Lets find out by writing one ourselves&hellip;</p>
    </a-slide>

    <a-slide>
      <h2>The <code>random</code> keyword</h2>
      <p>A random number between 0 and 1</p>
      <div>
        <code-block language="css">
          .foo {
            width: calc(**random** * 100%);
            background: hsl(calc(**random** * 360), 50%, 50%);
            opacity: **random**;
          }
        </code-block>
        <a href="demos/1/" class="small" target="_blank">View demo &#8594;</a>
      </div>
    </a-slide>

    <a-slide>
      <blockquote>
        <p>How do you tell the browser about a keyword it doesn't already understand?</p>
      </blockquote>
    </a-slide>

    <a-slide>
      <p>You can't.</p>
      <p part>You're limited to set things<br>
      the browser already knows about.</p>
    </a-slide>

    <a-slide>
      <h2>How polyfills work</h2>
      <p part>Fundamentally, all polyfills do one thing.</p>
      <p part>They turn code the browser <strong>doesn't</strong> understand<br>into code the browser <strong>does</strong> understand.</p>
      <div part class="FlexLine FlexLine--center">
        <div class="FlexLine-item">
          <code-block language="css">
            calc(**random** * 100%);
          </code-block>
        </div>
        <div class="FlexLine-item">
          <svg class="Icon" viewBox="0 0 24 24">
            <use xlink:href="icons.svg#icon-arrow-forward"></use>
          </svg>
        </div>
        <div class="FlexLine-item">
          <code-block language="css">
            calc(**0.4815162342** * 100%);
          </code-block>
        </div>
      </div>
    </a-slide>

    <a-slide>
      <blockquote>
        <p>It's just a simple find and replace?<br>That's easy!</p>
      </blockquote>
    </a-slide>

    <a-slide>
      <h2>The CSS Object Mobel</h2>
      <ul>
        <li><code>document.styleSheets</code></li>
        <li><code>CSSStyleSheetList</code></li>
        <li><code>CSSRuleList</code></li>
        <li><code>CSSMediaRule</code></li>
        <li><code>CSSStyleRule</code></li>
        <li><code>CSSStyleDeclaration</code></li>
      </ul>
    </a-slide>

    <a-slide>
      <code-block language="javascript">
        for (const stylesheet of document.styleSheets) {
          const rules = [...stylesheet.rules].reduce((prev, next) => {
            return prev.concat(next.cssRules ? [...next.cssRules] : [next]);
          }, []); // Flattens nested rules into a single array.

          for (const rule of rules) {
            for (const property of Object.keys(rule.style)) {
              const value = rule.style[property];

              if (value.includes('random')) {
                rule.style[property] = value.replace('random', Math.random());
              }
            }
          }
        }
      </code-block>
      <a href="demos/2/" target="_blank">View demo &#8594;</a>
    </a-slide>

    <a-slide>
      <h2>Harsh truths of polyfilling CSS</h2>
      <ul>
        <li>The CSSOM is not your friend</li>
      </ul>
    </a-slide>

    <a-slide>
      <blockquote>
        <p>If we can't get the styles from the CSSOM, how do we get them?</p>
      </blockquote>
    </a-slide>

    <a-slide>
      <h2>Harsh truths of polyfilling CSS</h2>
      <ul>
        <li>The CSSOM is not your friend</li>
        <li part>You have to fetch and parse the styles yourself</li>
      </ul>
    </a-slide>

    <a-slide>
      <h2>Fetching styles manually</h2>
      <code-block language="javascript">
        function getPageStyles() {
          // Query the document for any element that could have styles.
          var styleElements =
              [...document.querySelectorAll('style, link[rel="stylesheet"]')];

          // Fetch all styles and ensure the results are in document order.
          // Resolve with a single string of CSS text.
          return Promise.all(styleElements.map((el) => {
            if (el.href) {
              return fetch(el.href).then((response) => response.text());
            } else {
              return el.innerText;
            }
          })).then((stylesArray) => stylesArray.join('\n'));
        }
      </code-block>
      <a href="demos/3/" target="_blank">View demo &#8594;</a>
    </a-slide>

    <a-slide>
      <h2>Parsing the fetched Styles</h2>
      <p>Instead of writing our own parser, we import PostCSS.</p>
      <code-block language="javascript">
        import postcss from 'postcss';
        import getPageStyles from '../src/get-page-styles';

        getPageStyles()
          .then((css) => postcss.parse(css))
          .then((ast) => console.log(ast));
      </code-block>
      <a href="demos/4/" target="_blank">View demo &#8594;</a>
    </a-slide>

    <a-slide>
      <p>By fetching and parsing the CSS ourselves, we've effectively created our own CSS Object Model.</p>
      <p part>This object is also commonly known as an Abstract Syntax Tree (AST).</p>
      <p part>Now that we have an AST, we can loop through each rule and replace the <code>random</code> keyword with a random number.</p>
    </a-slide>

    <a-slide>
      <h2>Next steps</h2>
      <ul>
        <li part>Loop through each style declaration in the AST</li>
        <li part>If the declaration contains the <code>random</code> keyword, replace it.</li>
        <li part>Once done, replace the page styles with the modified styles.</li>
      </ul>
    </a-slide>

    <a-slide>
      <h3>Modifying the AST</h3>
      <p>PostCSS already has a plugin system for modifying its AST,<br>
      so we can use that to avoid writing a lot more code.</p>
      <code-block language="javascript">
        const randomKeywordPlugin = postcss.plugin('random-keyword', () => {
          return (css) => {
            css.walkRules((rule) => {
              rule.walkDecls((decl, i) => {
                if (decl.value.includes('random')) {
                  decl.value = decl.value.replace('random', Math.random());
                }
              });
            });
          };
        });
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Replacing the page styles</h3>
      <code-block language="javascript">
        function replacePageStyles(css) {
          // Get a reference to all existing style elements.
          const existingStyles =
              [...document.querySelectorAll('style, link[rel="stylesheet"]')];

          // Create a new &lt;style&gt; tag with all the polyfilled styles.
          const polyfillStyles = document.createElement('style');
          polyfillStyles.innerText = css;
          document.head.appendChild(polyfillStyles);

          // Remove the old styles once the new styles have been added.
          existingStyles.forEach((el) => el.parentElement.removeChild(el));
        };
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Putting it all together</h3>
      <code-block language="javascript">
        import postcss from 'postcss';
        import getPageStyles from '../src/get-page-styles';
        import randomKeyworkPlugins from '../src/random-keyword-plugin';
        import replacePageStyles from '../src/replace-page-styles';

        getPageStyles()
          .then((css) => postcss([randomKeywordPlugin]).process(css))
          .then((result) => replacePageStyles(result.css));
      </code-block>
      <a href="demos/5/" target="_blank">View demo &#8594;</a>
    </a-slide>

    <a-slide>
      <h2>What are our options?</h2>
      <ul>
        <li>Add inline styles to every element matching the rule selector</li>
      </ul>
    </a-slide>

    <a-slide>
      <code-block language="javascript">
        const randomKeywordPlugin = postcss.plugin('random-keyword', () => {
          return (css) => {
            css.walkRules((rule) => {
              rule.walkDecls((decl, i) => {
                if (decl.value.includes('random')) {
        **          const elements = document.querySelectorAll(rule.selector);**
        **          for (const element of elements) {                         **
        **            element.style[decl.prop] =                              **
        **                decl.value.replace('random', Math.random());        **
        **          }                                                         **
                }
              });
            });
          };
        });
      </code-block>
      <a href="demos/6/" target="_blank">View demo &#8594;</a>
    </a-slide>

    <a-slide>
      <h2>What are our options?</h2>
      <ul>
        <li><s>Add inline styles to every element matching the rule selector</s></li>
        <li part>Check the rest of the CSS for matching rules and then apply the final, merged set of properties as inline style on each matching element.<span part>..of&nbsp;course also accounting for specificity, so we'll also have to manually parse each selector and calculate its specificity. Then we can sort the matching rules in specificity order from low to high.<span style="font-size: .9em"  part>..oh and then there's <code>@media</code> rules that we'll have to manually determine if they match and account for them.</span><span style="font-size: .8em" part>..and speaking of at-rules, there's also <code>@support</code> rules&mdash;can't forget about those.</span><span style="font-size: .7em"  part>&hellip;and lastly we'll also have to account for property inheritance, so we'll have to traverse the DOM tree to get the full set of computed properties.</span><span style="font-size: .6em"  part>..oh just kidding, there's one more. We'll also have to account for <code>!important</code> declarations, which are calculated per-property instead of per-rule, so we'll have to maintain a separate mapping to figure out which <code>!important</code> declaration should ultimately apply.</span>
        </li>
      </ul>
    </a-slide>

    <a-slide>
      <blockquote>
        <p>Wait, didn't you just describe the cascade?</p>
      </blockquote>
    </a-slide>

    <a-slide>
      <p>Yes.<span part> Yes I did.</p>
    </a-slide>

    <a-slide>
      <h2>What are our options?</h2>
      <ul>
        <li><s>Add inline styles to every element matching the rule selector</s></li>
        <li><s>Reimplement the entire cascade manually</s></li>
        <li part>Rewrite the CSS to target individual elements while maintaining specificity order.</li>
      </ul>
    </a-slide>

    <a-slide>
      <h2>Rewriting the CSS</h2>
      <div class="FlexLine FlexLine--center">
        <div class="FlexLine-item">
          <code-block language="css">
            * {
              box-sizing: border-box;
            }
            p {
              opacity: random;
            }
            .foo {
              opacity: initial;
            }
          </code-block>
        </div>
        <div class="FlexLine-item">
          <svg class="Icon" viewBox="0 0 24 24">
            <use xlink:href="icons.svg#icon-arrow-forward"></use>
          </svg>
        </div>
        <div class="FlexLine-item" style="position: relative">
          <div>
            <code-block language="css">
              * {
                box-sizing: border-box;
              }
              p**[pid="1"]** {
                opacity: .23421;
              }
              p**[pid="2"]** {
                opacity: .82305;
              }
              p**[pid="3"]** {
                opacity: .31178;
              }
              .foo {
                opacity: initial;
              }
            </code-block>
            <code-block part language="css" style="position: absolute; top: 0; left: 0">
              *&#8203;**:not(.z)** {
                box-sizing: border-box;
              }
              p[pid="1"] {
                opacity: .23421;
              }
              p[pid="2"] {
                opacity: .82305;
              }
              p[pid="3"] {
                opacity: .31178;
              }
              .foo**:not(.z)** {
                opacity: initial;
              }
            </code-block>
          </div>
        </div>
      </div>
    </a-slide>


    <a-slide>
      <h3>Targeting matching elements</h3>
      <code-block language="javascript">
        css.walkRules((rule) => {
          const newRules = {};
          rule.walkDecls((decl, i) => {
            if (decl.value.match('random')) {
              for (const el of **document.querySelectorAll(rule.selector)**) {
                const pid = el.dataset.pid || (el.dataset.pid = getUniqueId());
                const newRule = newRules[pid] || (newRules[pid] = rule.clone({
                  selector: **appendToSelector(rule.selector, `[data-pid="${pid}"]`)**,
                  nodes: [],
                }));
                newRule.nodes.push(decl.clone({
                  value: **decl.value.replace('random', Math.random())**,
                }));
              }
            }
            // ...
      </code-block>
    </a-slide>

    <a-slide>
      <h3>"Up-specifizing" all rules</h3>
      <code-block language="javascript">
        // ...

            // Clone the current rule and update the selector.
            rule.parent.insertBefore(rule, rule.clone({
              selector: appendToSelector(rule.selector, **':not(.z)'**)
            }))

            // Insert all the new rules before the current rule.
            for (const id of Object.keys(newRules)) {
              rule.parent.insertBefore(rule, newRules[id]);
            }

            // Remove the current rule and continue iterating.
            rule.remove();
          });
        });
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Putting it all together</h3>
      <code-block language="javascript">
        import postcss from 'postcss';
        import randomKeywordPlugin from '../src/random-keyword-plugin';
        import getPageStyles from '../src/get-page-styles';
        import replacePageStyles from '../src/replace-page-styles';

        getPageStyles()
          .then((css) => postcss([randomKeywordPlugin]).process(css))
          .then((result) => replacePageStyles(result.css));
      </code-block>
      <a href="demos/7/" target="_blank">View demo &#8594;</a>
    </a-slide>

    <a-slide>
      <blockquote>
        <p>Zomg! You've solved Polyfilling in CSS!</p>
      </blockquote>
    </a-slide>

    <a-slide>
      <p>No. <span part>No I haven't.</span></p>
    </a-slide>

    <a-slide>
      <h2>Shortcomings of this approach</h2>
      <ul>
        <li part>Doesn't work with cross-origin (non-CORS) stylesheets.</li>
        <li part>Performs horribly if needed to run often (scroll/resize handlers).</li>
        <li part>Needs to re-run every time the DOM changes.</li>
      </ul>
    </a-slide>

    <a-slide>
      <h2>The browser rendering pipeline</h2>
      <div style="position: relative; display: inline-block; width:1440px; height:700;">
        <img width="100%" height="100%" src="images/render-pipeline.svg" style="display: block">
        <img part width="100%" height="100%" src="images/render-pipeline-polyfill.svg" style="position: absolute; left: 0; top: 0;">
      </div>
    </a-slide>


    <a-slide>
      <p>List of things the browser already does for us, but because we as developers don't have hooks into that process, we have to redo it entirely on our own.</p>
      <ul>
        <li>Fetching the CSS</li>
        <li>Parsing the CSS</li>
        <li>Handling the Cascade</li>
        <li>Invalidating styles</li>
        <li>Revalidating styles</li>
      </ul>
    </a-slide>

    <a-slide>
      <h3>Without Houdini APIs,<br>CSS polyfills will be either:</h3>
      <ul>
        <li>Too big</li>
        <li>Too slow</li>
        <li>Too buggy</li>
      </ul>
    </a-slide>



  </a-slide-deck>

</body>
</html>

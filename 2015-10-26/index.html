<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Web Components and the future of Modular CSS &mdash; CSSDevConf (Oct. 16, 2015)</title>

  <script src="bower_components/webcomponentsjs/webcomponents-lite.js"></script>

  <link rel="import" href="bower_components/slide-deck/a-slide-deck.html">
  <link rel="import" href="bower_components/slide-deck/a-slide.html">
  <link rel="import" href="bower_components/slide-deck/code-block.html">

  <link rel="import" href="elements/emoji-con.html">
  <link rel="import" href="elements/flex-line.html">

  <link rel="stylesheet" href="theme.css">
</head>
<body unresolved>

  <a-slide-deck width="1024" height="768">

    <a-slide>
      <hgroup>
        <h1>Web Components</h1>
        <h2>And the future of Modular CSS</h2>
      </hgroup>
      <p>
        <a href="http://philipwalton.com">Philip Walton</a> /
        <a href="https://twitter.com/philwalton">@philwalton</a>
      </p>
    </a-slide>

    <a-slide>
      <h2>I have good news <span part><br>and bad news</span></h2>
    </a-slide>

    <a-slide>
      <h2>The good news</h2>
      <p part>For a long time Web Components were primarily a Google effort, but now all browser vendors are on board.</p>
      <p part>Web Components will likely work natively in all browsers sometime in 2016.</p>
      <p part><strong>#shadowdom2016</strong> <emoji-con name="hand-with-first-and-second-fingers-crossed"></emoji-con></p>
    </a-slide>

    <a-slide>
      <h2>The bad news</h2>
      <p part>In order for everyone to come to agreement, the spec had to change.</p>
      <p part>When I submitted this talk proposal, Chrome had a native implementation of all Web Component features.</p>
      <p part>Now none of the browsers do. <emoji-con name="disappointed-face"></emoji-con></p>
    </a-slide>

    <a-slide>
      <h3>What has changed?</h3>
      <ul>
        <li part>The <code>createShadowRoot()</code> method has been renamed to <code>attachShadow(mode)</code>.</li>
        <li part>Multiple shadow roots have gone away (for now).</li>
        <li part>The <code>&lt;content select&gt;</code> element has been renamed to <code>&lt;slot name&gt;</code>, and the <code>::content</code> pseudo-element to <code>::slotted</code>.</li>
        <li part>The shadow piercing combinators and pseudo-elements (e.g. <code>/deep/</code>, <code>>>></code>, <code>::shadow</code>) have been removed.</li>
      </ul>
    </a-slide>

    <a-slide>
      <h3>A note about the demos</h3>
      <p part>Because the spec is currently in flux, I couldn't have working demos that also used current standards.</p>
      <p part>I choose to show working demos, so people could download them and experiment themselves.</p>
      <p part>Keep in mind the syntax has changed slightly. <span part>Luckily, the underlying, fundamental concepts are still the same. And that's the important part.</span></p>
    </a-slide>

    <a-slide>
      <h2>Why should CSS developers care about Web Components?</h2>
      <p part class="big">I actually think CSS Developers have the <strong>most</strong> reason to care!</p>
    </a-slide>

    <a-slide>
      <h3>To understand why, let's first look at what makes CSS hard today.</h3>
      <flex-line>
        <ul>
          <li part>Managining global names</li>
          <li part>Scoping/isolating styles</li>
          <li part>Specificity conflicts</li>
        </ul>
        <ul>
          <li part>Unpredictable matching</li>
          <li part>Managing style dependencies</li>
          <li part>Removing unused code</li>
        </ul>
      </flex-line>
    </a-slide>

    <a-slide>
      <h3>What do all these have in common?</h3>
      <flex-line>
        <div flex part>
          <p>Hint, it's not these&hellip;</p>
          <code-block>
            ~~#sidebar ul li a {~~
              color: blue;
              display: block;
              padding: 1em;
            ~~}~~
          </code-block>
        </div>
        <div flex part>
          <p>&hellip;it's these</p>
          <code-block>
            #sidebar ul li a {
              ~~color: blue;
              display: block;
              padding: 1em;~~
            }
          </code-block>
        </div>
      </flex-line>
    </a-slide>

    <a-slide>
      <h3>Your selectors are the biggest determining factor in how scalable your code is.</h3>
      <p part>Selectors are globals. It’s hard to write predictable code when any rule you write could potentially conflict with another rule you didn’t know existed.</p>
      <p part>Writing bad selectors today will likely cripple your ability to makes changes to the front-end in the future.</p>
    </a-slide>

    <a-slide>
      <h3>What are bad selectors?</h3>
      <p part>Selectors that cast a wide net increase the chances of unintended matches.</p>
      <p part>And for whatever reason, people who write CSS like to live dangerously!</p>
      <div part>
        <code-block language="css">
          #main #content div div div {
            float: left;
            width: 50%;
          }
        </code-block>
        <p>This is not a joke. This actually happened.</p>
      </div>
    </a-slide>

    <a-slide>
      <h3>Okay, but my selectors aren't <em>that</em> bad.</h3>
      <p part>Yes, they are.</p>
      <p part>In my experience, pretty much all selectors are bad.</p>
      <p part>The only selectors that even kind of scale are selectors that target a single class.</p>
    </a-slide>

    <a-slide>
      <h3>But that means adding a lot of classes to your markup.</h3>
      <p part>Which too often ends up looking like this:</p>
      <div part>
        <code-block language="html">
          <nav class="navbar navbar-default">
            <div class="container-fluid">
              <div class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                  <!-- ... -->
                </ul>
              </div>
            </div>
          </nav>
        </code-block>
        <p>Are all these classes needed? What do they do? If I remove one of them will everything break? WTF is going on? <strong>#FML</strong></p>
      </div>
    </a-slide>

    <a-slide>
      <h2>So what is the answer?</h2>
      <p part class="big">If selectors that depend the markup structure is bad,
        <span part>and if markup full of implementation details is bad,</span>
        <span part>how should we be writing CSS?</span></p>
    </a-slide>

    <a-slide>
      <p>The problem isn't that our CSS is bad, the problem is it's operating on far too much DOM.</p>
      <p part>The real question isn't "how do I write good CSS?" It's:</p>
      <p part class="big">How should we change CSS to make it harder to screw up?</p>
    </a-slide>

    <a-slide>
      <h2>What is CSS missing?</h2>
      <p part>If I could change anything about HTML and CSS to make these problems easier to solve, what would it be?</p>
      <ul>
        <li part>The ability to scope or isolate styles to a particular set of DOM nodes.</li>
        <li part>The ability to hide away implementation details.</li>
      </ul>
      <p part>As it turns out, Web Components (specifically Shadow DOM) gives us both of these.</p>
    </a-slide>

    <a-slide>
      <h2>But wait!</h2>
      <p part class="big">Why should we change CSS? Aren't these problems already solved by:</p>
      <ul>
        <li part>React</li>
        <li part>Inline styles</li>
        <li part>CSS Modules</li>
        <li part>BEM / SMACSS / OOCSS /
          <span class="small">AMCSS /
          <span class="small">ITCSS /
          <span class="small">FUNCSS /
          <span class="small">ACSS /
          <span class="small">WTFCSS /
          <span class="small">ETCCSS&hellip;
          </span></span></span></span></span></span>
        </li>
      </ul>
    </a-slide>

    <a-slide>
      <h1><div class="big center">NO!</div></h1>
    </a-slide>

    <a-slide>
      <h3>Ok, maybe a little bit&hellip;</h3>
      <p>But there are some key differences between the current solutions and Web Components:</p>
      <ul>
        <li part>Existing solutions leverage tools and conventions to address the problems.</li>
        <li part>Tools and conventions take time to learn and raise the barrier to entry.</li>
        <li part>And they only address the symptoms of the problem. They don't address the underlying cause. They can't.</li>
      </ul>
    </a-slide>

    <a-slide>
      <h3>What are the benefits of a platform-based solution?</h3>
      <ul>
        <li part>No extra knowledge required. If you could write CSS five years ago, you can write it today with Web Components.</li>
        <li part>No framework, library, or build tool dependencies.</li>
        <li part>Interoperability. We can finally write components that aren't <code>jquery-*</code>, <code>react-*</code>, or <code>angular-*</code> plugins.</li>
      </ul>
    </a-slide>

    <a-slide>
      <p class="center big">Sold yet? <span part>Ok, let's dive in!</span></p>
    </a-slide>

    <a-slide>
      <h2>The Anatomy of a Web Component</h2>
      <ul>
        <li><strong>A Custom Element</strong>: defines the component as an HTML tag.</li>
        <li><strong>HTML Imports</strong>: declares any other element or asset dependencies.</li>
        <li><strong>Shadow DOM</strong>: Defines the private DOM and the insertion points for the main DOM.</li>
        <li><strong>Template Element</strong>: a Shadow DOM is usually created by cloning a template element.</li>
      </ul>
    </a-slide>

    <a-slide>
      <h2>Shadow DOM</h2>
      <p class="big">What is it, and how can I get me some?</p>
      <p part>Shadow DOM is a subtree of DOM nodes that you can create on any HTML element.</p>
      <p part>The shadow DOM subtree gets merged into the main DOM, but unlike the main DOM tree, shadow nodes can't be styled from outside.</p>
      <p part>In short, shadow nodes are private.</p>
    </a-slide>

    <a-slide>
      <h3>A simple example:</h3>
      <code-block language="js">
        // Creates a new paragraph element and adds it to the DOM.
        var p = document.createElement('p');
        document.body.appendChild(p);

        // Creates a shadow root on an the paragraph.
        **p.createShadowRoot()**;

        // Sets the paragraph's shadow root's HTML contents.
        **p.shadowRoot.innerHTML** = 'Sweet <em>sweet</em> contents...';
      </code-block>
      <small>
        <a href="demos/shadow-dom-demo.html" target="_blank">
          Shadow DOM demo →
        </a>
      </small>
    </a-slide>

    <a-slide>
      <h2>Custom Elements</h2>
      <p>Custom elements are initially defined as JavaScript classes.</p>
      <p>They extend <code>HTMLElement</code> and then get registered on the document for use as a specific HTML tag.</p>
      <p>Custom elements typically create a shadow root in their <code>createdCallback</code> lifecycle method.</p>
    </a-slide>


    <a-slide>
      <h3>A simple example:</h3>
      <code-block language="js">
        // Creates a MediaObjectElement class that extends HTMLElement.
        class MediaObjectElement extends HTMLElement {
          createdCallback() {
            var shadowRoot = this.createShadowRoot();
            shadowRoot.innerHTML = 'Shadow DOM contents...';
          }
        }

        // Registers the `&lt;media-object&gt;` element for use.
        document.registerElement('media-object', MediaObjectElement);
      </code-block>
      <p part>Note, the other lifecycle methods are <code>attachedCallback</code>, <code>detachedCallback</code>, and <code>attributeChangedCallback</code>.</p>
    </a-slide>

    <a-slide>
      <h2>HTML Imports</h2>
      <p>HTML Imports are a way to package up a custom element and any of its dependencies into a single file.</p>
      <p part>You no longer need to manage a component's HTML, CSS, and JavaScript dependencies separately.</p>
      <p part>Other custom elements (or the main document) and then "import" the imports before using them.</p>
    </a-slide>

    <a-slide>
      <h2>Templates</h2>
      <p>Template are inert bits of DOM. By "inert" I mean their contents aren't processed by the browser.</p>
      <p part>Templates are typically used to define a reusable bit of DOM that can be cloned and inserted into the main DOM.</p>
      <p part>Templates are typically used to store an elements Shadow DOM contents before it's created and added to the page.</p>
    </a-slide>

    <a-slide>
      <h3>A template and import example:</h3>
      <p>A <code>super-element.html</code> component definition:</p>
      <code-block language="html">
        &lt;link rel="import" href="dependent-element.html"&gt;

        <template>
          <style>/* Shadow DOM styles */</style>
          <dependent-element></dependent-element>
        </template>

        &lt;script>
          class SuperElement extends HTMLElement {
            createdCallback() {
              this.createShadowRoot().innerHTML =
                  document.querySelector('template').innerHTML;
            }
          }
          document.registerElement('super-element', SuperElement);
        &lt;/script>
      </code-block>
    </a-slide>

    <a-slide>
      <h3>How does Shadow DOM interact with the main DOM?</h3>
      <p>Shadow DOM uses the <code>&lt;content&gt;</code> element to define insertion points. The insertion points house the main DOM.</p>

      <flex-line>
        <div flex>
          <p>The main DOM:</p>
          <code-block language="html">
            <media-object>
              <h1>&hellip;</h1>
              <img>
              <p>&hellip;</p>
            </media-object>
          </code-block>
        </div>
        <div>
          <p>Shadow DOM:</p>
          <code-block language="html">
            <figure>
              <content select="img"></content>
            </figure>
            <div>
              <content></content>
            </div>
          </code-block>
        </div>
      </flex-line>

    </a-slide>

    <a-slide>
      <h3>The final, composed DOM tree</h3>

      <code-block language="html">
        <media-object>
          ~~<figure>~~
            <img>
          ~~</figure>~~
          ~~<div>~~
            <h1>&hellip;</h1>
            <p>&hellip;</p>
          ~~</div>~~
        </media-object>
      </code-block>

    </a-slide>


    <a-slide>
      <h3>What does modular CSS with Shadow DOM look like?</h3>
      <p part>Most software development techniques for modularity and code reuse center around two principles.</p>
      <ul>
        <li part>Inheritance</li>
        <li part>Composition</li>
      </ul>
    </a-slide>

    <a-slide>
      <h2>Inheritance</h2>
      <p>Inheritance generally establishes an <strong>is-a</strong> relationship.</p>
      <code-block language="html">
        <!-- Inheritance in OOCSS: -->
        <div class="media-object profile-card"></div>
      </code-block>

      <code-block language="scss">
        // Inheritance in Sass
        .profile-card {
          @extends .media-object;
          /* ... */
        }

        // Usage: <div class="profile-card"></div>
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Inheritance with Web Components</h3>
      <p>The extending component will typically:
      <ul>
        <li>Include the base component.</li>
        <li>Call the base components <code>createdCallback</code> to create the base shadow root.</li>
        <li>Create a new style tag with additional styles and append it to the shadow root.</li>
      </ul>
    </a-slide>

    <a-slide>
      <p><code>&lt;profile-card&gt;</code> extends <code>&lt;media-object&gt;</code>:</p>
      <code-block language="html">
        &lt;link rel="import" href="media-object.html"&gt;

        <template>
          <style>/* Additional, profile-card-only styles. */</style>
        </template>

        &lt;script>
          class ProfileCardElement extends MediaObjectElement {
            createdCallback() {
              super.createdCallback();
              this.shadowRoot.innerHTML +=
                  document.querySelector('template').innerHTML;
            }
          }
          document.registerElement('profile-card', ProfileCardElement);
        &lt;/script>
      </code-block>
      <small>
          <a href="demos/media-object-demo.html" target="_blank">
            Media object demo
          </a>
          &nbsp;|&nbsp;
          <a href="demos/profile-card-demo.html" target="_blank">
            Profile card demo
          </a>
        </small>
    </a-slide>

    <a-slide>
      <h2>Composition</h2>
      <p>Composition generally establishes a <strong>has-a</strong> relationship.</p>
      <code-block language="html">
        <!-- Composition in BEM: -->
        <div class="Catalog">
          <div class="Grid">
            <div class="Grid-cell">
              <div class="Catelog-item">&hellip;</div>
            </div>
            <div class="Grid-cell">
              <div class="Catelog-item">&hellip;</div>
            </div>
            <div class="Grid-cell">
              <div class="Catelog-item">&hellip;</div>
            </div>
          </div>
        </div>
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Composition with Web Components</h3>
      <p>The composing component will:
      <ul>
        <li>Include the base component.</li>
        <li>Use the base component elements in its shadow DOM.</li>
      </ul>
      <p>Composition usually involves building a complex element from one or more base elements.</p>
    </a-slide>

    <a-slide>
      <h3>Base elements</h3>
      <p>The media object is a classic OOCSS base element.</p>
      <p>Base elements typically define layout and positioning while leaving color and ornamentation unspecified.</p>
    </a-slide>

    <a-slide>
      <h3>Example layout primitives</h3>
      <flex-line>
        <div flex>
          <p>The <code>&lt;flex-grid&gt;</code> element:</p>
          <code-block language="html">
            <flex-grid>
              <div>&hellip;</div>
              <div>&hellip;</div>
              <div>&hellip;</div>
              <div>&hellip;</div>
              <div>&hellip;</div>
              <div>&hellip;</div>
            </flex-grid>
          </code-block>
          <small>
            <a href="demos/flex-grid-demo.html" target="_blank">
              Flex grid demo &nbsp;&#8594;
            </a>
          </small>
        </div>
        <div flex>
          <p>The <code>&lt;flex-line&gt;</code> element:</p>
          <code-block language="html">
            <flex-line>
              <div>&hellip;</div>
              <div flex>&hellip;</div>
              <flex-line column>
                <div flex>&hellip;</div>
                <div flex>&hellip;</div>
              </flex-line>
            </flex-line>
          </code-block>
          <small>
            <a href="demos/flex-line-demo.html" target="_blank">
              Flex line demo &nbsp;&#8594;
            </a>
          </small>
        </div>
      </flex-line>
    </a-slide>

    <a-slide>
      <h3>Building layouts from composable primitives.</h3>
      <p part><code>&lt;flex-line&gt;</code> and <code>&lt;flex-grid&gt;</code> are very presentational, so you might not want to have them appear in your main document source.</p>
      <p part>Luckily, you don't have to.</p>
      <p part>The next example uses <code>&lt;flex-line&gt;</code> in its shadow DOM to build the classic "Holy Grail" layout.</p>
    </a-slide>


    <a-slide>
      <flex-line>
        <div flex auto>
          <p>The main DOM:</p>
          <code-block language="html">
            <holy-grail>
              <header>&hellip;</header>
              <main>&hellip;</main>
              <nav>&hellip;</nav>
              <aside>&hellip;</aside>
              <footer>&hellip;</footer>
            </holy-grail>
          </code-block>
          <small>
            <a href="demos/holy-grail-demo.html" target="_blank">
              Holy grid demo &nbsp;&#8594;
            </a>
          </small>
        </div>
        <div flex auto>
          <p>The shadow DOM:</p>
          <code-block language="html">
            <flex-line column>
              <demo-box>
                <content select="header"></content>
              </demo-box>
              <flex-line flex>
                <demo-box flex>
                  <content select="main"></content>
                </demo-box>
                <demo-box>
                  <content select="nav"></content>
                </demo-box>
                <demo-box>
                  <content select="aside"></content>
                </demo-box>
              </flex-line>
              <demo-box>
                <content select="footer"></content>
              </demo-box>
            </flex-line>
          </code-block>
        </div>
      </flex-line>
    </a-slide>

    <a-slide>
      <h3>The final, composed DOM tree</h3>
      <code-block language="html">
        <holy-grail>
          ~~<flex-line column>~~
            ~~<div>~~<header>&hellip;</header>~~</div>~~
            ~~<flex-line flex>~~
              ~~<div flex>~~
                <main>&hellip;</main>~~
              </div>~~
              ~~<div>~~
                <nav>&hellip;</nav>~~
              </div>~~
              ~~<div>~~
                <aside>&hellip;</aside>~~
              </div>~~
            ~~</flex-line>~~
            ~~<div>~~<footer>&hellip;</footer>~~</div>~~
          ~~</flex-line>~~
        </holy-grail>
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Composition + inheritance</h3>
      <p>Building a <code>&lt;profile-card-gallary&gt;</code> element from:
      <ul>
        <li><code>&lt;profile-card&gt;</code></li>
        <li><code>&lt;media-object&gt;</code></li>
        <li><code>&lt;flex-grid&gt;</code></li>
      </ul>
    </a-slide>

    <a-slide>
      <h3>The profile card structure</h3>
      <flex-line>
        <div flex auto>
          <p>The main DOM:</p>
          <code-block language="html">
            <profile-card-gallery>
              <profile-card>~~&hellip;~~</profile-card>
              <profile-card>~~&hellip;~~</profile-card>
              <profile-card>~~&hellip;~~</profile-card>
              <profile-card>~~&hellip;~~</profile-card>
            </profile-card-gallery>
          </code-block>
        </div>
        <div flex auto>
          <p>The shadow DOM:</p>
          <code-block language="html">
            <profile-card-gallery>
              <flex-grid>
                <content
                  select="profile-card">
                </content>
              </flex-grid>
            </profile-card-gallery>
          </code-block>
        </div>
      </flex-line>
      <small>
        <a href="demos/profile-card-gallery-demo.html" target="_blank">
          Profile card gallery demo &nbsp;&#8594;
        </a>
      </small>
    </a-slide>

    <a-slide>
      <h3>The final, composed DOM tree</h3>
      <code-block language="html">
        <profile-card-gallery>
          ~~<flex-grid>~~
            <profile-card>~~[media-object]~~</profile-card>
            <profile-card>~~[media-object]~~</profile-card>
            <profile-card>~~[media-object]~~</profile-card>
            <profile-card>~~[media-object]~~</profile-card>
          ~~</flex-grid>~~
        </profile-card-gallery>
      </code-block>
    </a-slide>

    <a-slide>
      <h3>Custom component style</h3>
      <p>The <code>&lt;profile-card-gallery&gt;</code> component uses CSS custom properties to pass style data to the <code>&lt;flex-grid&gt;</code> element inside it's shadow DOM.</p>

      <code-block language="html">
        <style>
          flex-grid {
            --flex-grid-basis: 26em;
            --flex-grid-gutter: 1.5em;
          }
        </style>
      </code-block>

      <p>Custom properties replace the shadow piercing combinators as the de facto way to style third-party components.</p>
    </a-slide>

    <a-slide>
      <h3>Custom pseudo-elements</h3>
      <p>Custom properties work very well as a way to pass data through the shadow boundry in a way that a component can opt-in to receiving.</p>
      <p>In addition to custom properties, a future spec will likely define custom pseudo-elements for more direct third-party styling.</p>
    </a-slide>

    <a-slide>
      <p>Defining custom pseudo-elements in the Shadow DOM:</p>
      <code-block language="html">
        <!-- Inside <date-range-picker> element definition. -->
        <template>
          <div>
            <input **part="start-date"** type="date">
            <input **part="end-date"** type="date">
          </div>
        </template>
      </code-block>
      <p>Referencing custom pseudo-elements in external CSS:</p>
      <code-block language="css">
        date-range-picker**::part(start-date)**,
        date-range-picker**::part(end-date)** {
          font-size: 1.5em;
        }
      </code-block>
    </a-slide>

    <a-slide>
      <h2>Wrapping up</h2>
    </a-slide>

    <a-slide>
      <h3>Writing scalable CSS today is challenging</h3>
      <p>All CSS rules are global and they often conflict with other rules in unexpected ways.
      <p>Managing the global nature of CSS at scale usually involves littering the HTML with implementation details.</p>
      <p>Abstracting away these implementation details often requires complex build processes or templating systems that raise the barrier to entry for new developers.</p>
    </a-slide>

    <a-slide>
      <h3>Web Components solve all of these problems</h3>
      <p>And they solve them at the platform level, so the barrier to entry is not significantly raised.</p>
    </a-slide>

    <a-slide>
      <h3>Web Components will change how we think about modularizing our CSS.</h3>
      <p>Verbose naming conventions will go away; they'll no longer be necessary.</p>
      <p>CSS files will become smaller, self-contained style declarations that do one thing and one thing only.</p>
      <p>Components will be styled by composing and extending existing styles.</p>
      <p>Third-party components will no longer be themed by overriding style rules. It will be opt-in and selectively allowed by the component author.</p>
    </a-slide>

    <a-slide>
      <h3>Web Components are happening and they're happening soon.</h3>
      <p>You can already use most Web Components features (with the exception of Shadow DOM) via the webcomponents.js polyfill.</p>
      <p>I predict that Shadow DOM v1 will be available in all browsers within one year from today (it will happen when Safari 10 is released).</p>
      <p><strong>#shadowdom2016</strong></p>
    </a-slide>

    <a-slide>
      <h3>You can prepare for Web Components today</h3>
      <p>Start (or continue) thinking about your site design in terms of reusable components.</p>
      <p>Use a methodology like BEM, which will make the transition very natural.</p>
    </a-slide>

    <a-slide>
      <h3>I hate your Web Components,<br>and your face, and you!</h3>
      <p>The web platform will continue to work as it does today long into the future.</p>
      <p>If Web Components aren't the best solution to your problem, feel free to use another solution.</p>
      <p>Speaking for myself, I can't wait for a world in which Web Components, ES6 modules, and HTTP2 are fully supported everywhere.</p>
      <p>The future is bright!</p>
    </a-slide>

    <a-slide>
      <h1>The End</h1>
      <dl>
        <dt>Twitter</dt>
        <dd><a href="https://twitter.com/philwalton">@philwalton</a></dd>
        <dt>Website</dt>
        <dd><a href="http://philipwalton.com">philipwalton.com</a></dd>
        <dt>Slides</dt>
        <dd><a href="https://github.com/philipwalton/talks">github.com/philipwalton/talks</a></dd>
      </dl>
      <p>To vote for this talk, text <strong>(504) 229-6828</strong><br>
      and use the hashtag <strong>#webmod</strong>.</p>
      <blockquote>
        <tt>#webmod 5 Shadow DOM 2016!</tt>
      </blockquote>
    </a-slide>

  </a-slide-deck>

</body>
</html>
